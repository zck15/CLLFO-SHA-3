# Leakage Assessments on the Low-Latency First-Order Masked SHA-3  

**Table of Contents:**

- [Introduction](#introduction)
- [PROLEAD](#prolead)
  - [File Structure](#file-structure-prolead)
  - [Instructions](#instructions-prolead)
  - [Our Environment and Run Time](#our-environment-and-run-time-prolead)

- [VerMI](#vermi)
  - [Instructions](#instructions-vermi)

- [TVLA](#tvla)
  - [Experimental Setup](#experimental-setup)

  - [File Structure](#file-structure-tvla)

  - [Controller and Target Design on SAKURA-X](#controller-and-target-design-on-sakura-x)

  - [Measurement Scripts](#measurement-scripts)

- [Contact](#contact)

- [License](#license)


## Introduction

This directory corresponds to Section 6, *Leakage Evaluation*, of the paper [*Breaking Ground: A New Area Record for Low-Latency First-Order Masked SHA-3*](). We used [**PROLEAD**](https://github.com/ChairImpSec/PROLEAD), **Test Vector Leakage Assessment (TVLA)**, and [**VerMI**](https://github.com/vmarribas/VerMFi) to evaluate the leakage of the RTL designs located in the `..\hardware` directory. The goal of this directory is to reduce the difficulty of reproducing these experiments.

For **PROLEAD** and **VerMI**, we provide <u>running instructions</u> and <u>configuration files</u>.

For **TVLA**, due to the diversity of equipment across different labs, reproducing the TVLA experiments involves complex experimental setups and specialized skills. A detailed tutorial is beyond the scope of this artifact. To ease the burden of reproducing TVLA experiments, we provide <u>the RTL design for the testing board</u> and <u>the main testing scripts</u> as references. However, actual reproduction still requires additional effort, including but not limited to adjusting the RTL design for different testing boards, writing specific testing scripts, developing t-test calculation scripts, and more.

## PROLEAD

PROLEAD is a simulation-based leakage detection tool that evaluates the security of masking designs by directly analyzing the distribution of intermediate variables. PROLEAD can be used to assess both glitch-robust and glitch+wire-transition robust probing models. For more information, please refer to the original paper [*PROLEAD - A Probing-Based Hardware Leakage Detection Tool*](https://tches.iacr.org/index.php/TCHES/article/view/9822), the [Github repository](https://github.com/ChairImpSec/PROLEAD), and the [Wiki](https://github.com/ChairImpSec/PROLEAD/wiki).

### File Structure (PROLEAD)

- `.\PROLEAD\500million_notrans\`: Configuration file and output report for the test under the **glitch-robust** probing model using **500 million** simulations (traces).
- `.\PROLEAD\500million_trans\`: Configuration file and output report for the test under the **glitch+wire-transition robust** probing model using **500 million** simulations (traces).
- `.\PROLEAD\data processing\`: Custom data processing script for extracting data from the reports generated by PROLEAD and plotting.

### Instructions (PROLEAD)

- Instructions for using PROLEAD (For more detailed instructions, please refer to the official [Hardware beginner's guide](https://github.com/ChairImpSec/PROLEAD/wiki/Hardware-beginner's-guide)):

  - [Install PROLEAD](https://github.com/ChairImpSec/PROLEAD/wiki/Installation).
  - Synthesize the RTL code to generate the gate-level netlist. We used [Synopsys Design Compiler](https://www.synopsys.com/implementation-and-signoff/rtl-synthesis-test/dc-ultra.html); for details, refer to the [hardware directory](../hardware/README.md). We provide a copy of the netlist file generated by DC at `..\hardware\syn\netlist\keccak_top.v`.
  - [Run PROLEAD](https://github.com/ChairImpSec/PROLEAD/wiki/Hardware-beginner's-guide#run). We provide our configuration file `config.set` and run script `run.sh` as a reference. Note that this step may require significant memory and time, as detailed in [Our Environment and Run Time](#our-environment-and-run-time-prolead). A copy of our test output report, `Report.dat`, is also provided for reference.

- Data processing: Extract data from the report and generate plots.

  - Navigate to the directory `.\PROLEAD\data processing\`:

    ```
    cd .\PROLEAD\data processing\
    ```

  - Run `extract_data_and_plot.py` to generate the right-hand plot of Figure 11 from the paper.

    ```
    python extract_data_and_plot.py
    ```

### Our Environment and Run Time (PROLEAD)

Due to the large circuit size and the high number of simulations, running PROLEAD requires significant memory and time. Below is a summary of our environment and run times for reference.

- Our hardware and software environment:
  - CPU: AMD Ryzen Threadripper 3970X 3.7 GHz 32 Core / 64 Thread (60 threads used)
  - Memory: 256GB (56GB used)
  - Operating System: Ubuntu 22.04.3 LTS (GNU/Linux 5.15.146.1-microsoft-standard-WSL2)
  - PROLEAD Version: [44a15f5](https://github.com/ChairImpSec/PROLEAD/tree/44a15f5a962d6063f1d1a64405e9045e3fdb9efb)
- Run times:
  - 500million_notrans: ~110 hours (4.6 days)
  - 500million_trans: ~124 hours (5.2 days)
  - Data processing: Less than 1 second

## VerMI

VerMI is a verification tool designed for masked implementations to detect whether they satisfy non-completeness and uniformity. For more information, please refer to the original paper [*VerMI: Verification Tool for Masked Implementations*](https://doi.org/10.1109/ICECS.2018.8617841), and the [Github repository](https://github.com/vmarribas/VerMFi).

Since our design is too large for VerMI to check uniformity, we only assessed non-completeness.

**Note:** The [current official version](https://github.com/vmarribas/VerMFi/commit/237a9c2) has two minor bugs related to processing Verilog files and handling constant register inputs. With the kind and detailed help and guidance of the author, [Victor Arribas](https://github.com/vmarribas), we have fixed these issues. The corrected version has been uploaded to [**our forked repository**](https://github.com/zck15/VerMFi); **please use this version** for the following tests.

**Note:** VerMI currently only supports designs synthesized using [**Synopsys Design Compiler**](https://www.synopsys.com/implementation-and-signoff/rtl-synthesis-test/dc-ultra.html). It does not yet support the use of Yosys or externally provided synthesized netlists.

### Instructions (VerMI)

- **Install VerMI:** Download the [repository](https://github.com/zck15/VerMFi) and [compile it](https://github.com/zck15/VerMFi#compilation).

- **Prepare the RTL design files:**

  - Copy all files from the [RTL design](../hardware/src_rtl/) to a new folder `VerMFi installation path/test_files/sha-3/`.

  - Adjust the top module file `keccak_top.v` to meet VerMI's requirements (we provide the adjusted file at `./VerMI/keccak_top.v` for reference):

    - VerMI requires that registers for different shares have distinct names. Therefore, you need to adjust the code in the register section. Modify lines 88-92:

      ```
        keccak_state state_inst (
          .clk     (clk),
          .state_di(state_d),
          .state_qo(state_q)
        );
      ```

      to:

      ```
        reg [1600-1:0] state_q_0, state_q_1, state_q_2, state_q_3;
        always @(posedge clk) state_q_0 <= state_d[1*1600-1:0*1600];
        always @(posedge clk) state_q_1 <= state_d[2*1600-1:1*1600];
        always @(posedge clk) state_q_2 <= state_d[3*1600-1:2*1600];
        always @(posedge clk) state_q_3 <= state_d[4*1600-1:3*1600];
        assign state_q = {state_q_3, state_q_2, state_q_1, state_q_0};
      ```

    - Delete the comment on line 1 (the word `module` in this comment is a VerMI keyword and will cause an error):

        ```
        // keccak_top, the top module of the first-order masked keccak design.
        ```
        
    - Add the VerMI settings at the beginning of the file:

        ```
        // Input_shares: din_share0_i, din_share1_i.
        // Random_vars: random_i.
        // Regs_layer: state_q_0, state_q_1, state_q_2, state_q_3.
        ```


- **Run VerMI** (Execution time is approximately 2 minutes):
  - Run `./verif_tool test_files/sha-3/keccak_top.v`.
  - Enter `1` to select side-channel analysis.
  - Enter `3` to select non-completeness.
  - Enter `1` to select first-order analysis.
  - The program will output `Your program fulfills non_completeness property!`.

## TVLA

Test Vector Leakage Assessment (TVLA) is a widely recognized and extensively used method for experimental leakage assessments. For more information, please refer to the following articles: *Test vector leakage assessment (TVLA) methodology in practice*, [*Leakage Assessment Methodology: A Clear Roadmap for Side-Channel Evaluations*](https://doi.org/10.1007%2F978-3-662-48324-4).

**Note:** Due to the diversity of equipment across different labs, reproducing the TVLA experiments involves complex experimental setups and specialized skills. A detailed tutorial is beyond the scope of this artifact. To ease the burden of reproducing TVLA experiments, we provide the RTL design for the testing board and the main testing scripts as references. However, actual reproduction still requires additional effort, including but not limited to adjusting the RTL design for different testing boards, writing specific testing scripts, developing t-test calculation scripts, and more.

### Experimental Setup

Our primary experimental setup includes a testing board, an oscilloscope, and a host computer. The testing board contains two FPGAs: one for implementing the target design under test and another for controlling the experimental process. The oscilloscope is used to capture the power consumption of the target FPGA on the testing board. The host computer communicates with both the testing board and the oscilloscope, managing the experimental process and processing the power traces. The specific models and parameters are as follows:

- Evaluation Platform: [SAKURA-X](https://satoh.cs.uec.ac.jp/SAKURA/hardware/SAKURA-X.html)
  - Clock Frequency: 14.3 MHz
- Oscilloscope: [WaveRunner](https://www.teledynelecroy.com/oscilloscope/) 8404M
  - Sampling Rate: 1 GS/s

### File Structure (TVLA)

- `.\TVLA\sakura-x\`: RTL codes for SAKURA-X
  - `.\TVLA\sakura-x\target\sakura_x_main_fpga.v`: Top module for the target FPGA
    - `.\TVLA\sakura-x\target\mkMainFPGA.v`: [BSV](https://github.com/B-Lang-org/bsc/releases/latest/download/BSV_lang_ref_guide.pdf)-generated Verilog code, main functionality except for DUT
      - `.\TVLA\sakura-x\target\dut_wrapper.v`: Wrapper for the `keccak_top` module, interfacing with the BSV portion
      - `.\TVLA\sakura-x\target\BRAM1.v`: BRAM from the official [BSC](https://github.com/B-Lang-org/bsc/) library
      - `.\TVLA\sakura-x\target\FIFO2.v`: FIFO from the official [BSC](https://github.com/B-Lang-org/bsc/) library
  - `.\TVLA\sakura-x\target\sakura_x_main_fpga.xdc`: Pin constraints for the target FPGA
  - `.\TVLA\sakura-x\controller\sakura_x_ctrl_fpga.v`: Top module for the controller FPGA
    - `.\TVLA\sakura-x\controller\mkCtrlFPGA.v`: BSV-generated Verilog code, implements the main controller functionality
      - `.\TVLA\sakura-x\controller\FIFO2.v`: FIFO from the official BSC library
  - `.\TVLA\sakura-x\controller\sakura_x_ctrl_fpga.ucf`: Pin constraints for the controller FPGA
- `.\scripts\`: Python scripts for TVLA traces collection
  - `.\scripts\ttest.py`: Main script for traces collection
    - `.\scripts\myttest.py`: Wrapper for various steps of the experimental process
      - `.\scripts\myprotocol.py`: Functions for communicating with SAKURA
        - `.\scripts\protocol.toml`: Protocol definitions for communication with SAKURA

    - `.\scripts\mybytes.py`: Utility for processing byte data
    - `.\scripts\testvector_correct.txt`: Test vectors
    - `.\scripts\log_config.toml`: Log configuration


### Controller and Target Design on SAKURA-X

We developed the RTL code for the Controller and Target using [Bluespec SystemVerilog (BSV)](https://github.com/B-Lang-org/bsc/releases/latest/download/BSV_lang_ref_guide.pdf). Our BSV-related codes are not currently open-sourced.

To facilitate experiment replication, we have included the Verilog codes compiled by [Bluespec Compiler (BSC)](https://github.com/B-Lang-org/bsc/) and FPGA constraint files in the `.\TVLA\sakura-x\` directory. Below, we briefly introduce our design and the communication interface.

On the **Target FPGA**, in addition to the design under test, we integrated a Trivium-based pseudorandom number generator (PRNG) to generate fresh random numbers required during the operation of the design under test. Additionally, there is a communication module for receiving commands and input data from the Controller FPGA.

On the **Controller FPGA**, there is an asynchronous FIFO communication module with the FT2232H, a communication module with the Target FPGA, and the core experiment control module. The control module can automatically manage the Target FPGA to perform multiple encryption operations based on configuration. The order of the fix and random groups is controlled by a Trivium-based PRNG, and the generation of random inputs for the random group, as well as the input masks for both groups, is handled by another local Trivium-based PRNG.

The Controller communicates with the host PC via a UART serial interface, with the communication protocol detailed in the table below. Specific commands and data addresses are defined in the `.\scripts\protocol.toml` file.

| Protocol Name    | Message Type      | Packet Size | Message Length | Header Length | Header Slice 1 | Destination or Source            | Header Slice 2 | Message Type            | Header Slice 3                 | Description                   | Body Length | Description |
| ---------------- | ----------------- | ----------- | -------------- | ------------- | -------------- | -------------------------------- | -------------- | ----------------------- | ------------------------------ | ----------------------------- | ----------- | ----------- |
| HostToController | Command           | 8bit        | 3 Packets (P)  | 3 P           | 1st P          | 0-Target FPGA, 1-Controller FPGA | [7:6] in 2nd P | 2'b00-Command           | [5:0] in 2nd P, [7:0] in 3rd P | Command Content               | 0 P         | -           |
| HostToController | Data Request      | 8bit        | 3 P            | 3 P           | 1st P          | 0-Target FPGA, 1-Controller FPGA | [7:6] in 2nd P | 2'b01-Data Request      | [5:0] in 2nd P, [7:0] in 3rd P | Address for Data Request      | 0 P         | -           |
| HostToController | Data Transmission | 8bit        | 5 P            | 3 P           | 1st P          | 0-Target FPGA, 1-Controller FPGA | [7:6] in 2nd P | 2'b10-Data Transmission | [5:0] in 2nd P, [7:0] in 3rd P | Address for Data Transmission | 2 P         | Data        |
| ControllerToHost | Data Transmission | 8bit        | 3 P            | 1 P           | 1st P          | 0-Target FPGA, 1-Controller FPGA | -              | -                       | -                              | -                             | 2 P         | Data        |

### Measurement Scripts

**Communication with SAKURA**: 

- The communication protocol is defined in the `.\scripts\protocol.toml` file.
- Python functions for communication are provided in the `.\scripts\myprotocol.py` library.
- Usage examples can be found in `.\scripts\myttest.py`.

**Testing Process Overview**: The corresponding script is `.\scripts\ttest.py`.

1. **SAKURA Connection and Functional Testing**: Includes serial port connection, communication testing, DUT testing with test vectors, and sequence mode testing (where the DUT runs multiple algorithm iterations while interacting with the host once, corresponding to the oscilloscope’s sequence acquisition mode).
2. **Oscilloscope Connection and Configuration**: The oscilloscope is configured according to predefined settings. The Python library code for this part is not provided; refer to the notes section below.
3. **Waveform Collection**: Waveforms are collected repeatedly until the required number is reached. The approximate steps per loop are as follows (corresponding to the `sequence` function in `.\scripts\myttest.py`):
   - **Oscilloscope Arm Trigger**: The oscilloscope is set to sequence mode and will return all waveforms after a fixed number of triggers.
   - **Send Start Command to SAKURA Controller FPGA**: Instructs the Controller FPGA to begin the sequence mode experiment.
   - **Maintain a Trivium-Based PRNG on the Host**: Synchronize with the Controller FPGA to verify the number of experiments.
   - **Wait for SAKURA to Finish Execution**: Read and verify the PRNG value on the Controller FPGA.
   - **Request Waveforms from the Oscilloscope**: Handle any oscilloscope exceptions.
   - **Assign Waveforms to Fix and Random Groups**: Based on the PRNG on the host, waveforms are assigned to their respective groups (fixed group or random group) and stored.
4. **T-test Calculation**: This artifact does not include a script for t-test calculations. We recommend using the [SCAred](https://eshard.gitlab.io/scared/README.html) library and the paper [*Leakage Assessment Methodology: A Clear Roadmap for Side-Channel Evaluations*](https://doi.org/10.1007%2F978-3-662-48324-4) for reference.

**Time Estimate**: In our environment, trace collection takes approximately 70 hours.

**Notes**:

- Due to variations in experimental setups, the provided scripts may require debugging and adjustments.
- Regarding oscilloscope communication, different brands use different libraries. For our WaveRunner oscilloscope, we used the [lecroydso](https://github.com/gottmic/lecroydso) library.

## Contact

Please contact [Cankun Zhao](https://github.com/zck15) ([zck22@mails.tsinghua.edu.cn](mailto:zck22@mails.tsinghua.edu.cn)) if you have any questions, comments, if you found a bug that should be corrected, or if you want to reuse the codes or parts of them for your own research projects.

## License

Copyright (c) 2024, Cankun Zhao, Leibo Liu. All rights reserved.

Please see `..\LICENSE` for further license instructions.