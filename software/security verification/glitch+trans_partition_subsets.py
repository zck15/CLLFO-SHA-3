# glitch+trans_partition_subsets, partition index lists into independent 
# subsets under glitch+transition-robust probing model.
# Copyright (C) 2024, Cankun Zhao, Leibo Liu. All rights reserved.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTERS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Please see LICENSE and README for license and further instructions.
#
# Contact: zhaock97@gmail.com

import json

W = 64


def related_indices(index):
    # Input the index of a register, output indices of related registers that
    # use common chi inputs with the input register.
    # NOTE: different from `glitch_partition_subsets.py`, here, each index in
    # the output corresponds to ONE register:
    # (x, y, z, s) -> d_{s}[x, y, z]

    x, y, z, s = index

    # chi_list: chi inputs used in calculating this register
    chi_list = [(x, y, z),
                ((x + 1) % 5, y, z),
                ((x + 2) % 5, y, z)]

    # chi inputs used in Changing Of The Guard (COTG)
    j = W * y + z
    if j > 0:
        jj = (j - 11) % (5 * W)
        yy = jj // W
        zz = jj % W
        if x == 0:
            chi_list.append((0, yy, zz))
        if x == 1:
            chi_list.append((1, yy, zz))

    # find indices of registers which use chi inputs in chi_list
    index_list = []
    for xx, yy, zz in chi_list:
        # Different from `glitch_partition_subsets.py`, here, each index 
        # corresponds to ONE register:
        # (x, y, z, s) -> d_{s}[x, y, z]
        index_list += [(xx, yy, zz, s) for s in range(4)]
        index_list += [((xx - 1) % 5, yy, zz, s) for s in range(4)]
        index_list += [((xx - 2) % 5, yy, zz, s) for s in range(4)]
        # COTG
        jj = W * yy + zz
        j = (jj + 11) % (5 * W)
        if j > 0:
            y = j // W
            z = j % W
            if xx == 0:
                index_list += [(0, y, z, s) for s in range(4)]
            if xx == 1:
                index_list += [(1, y, z, s) for s in range(4)]

    # Remove duplicate indices
    index_list = list(set(index_list))
    # Remove index itself from index_list
    index_list.remove(index)
    return index_list


def partition_subsets(index_list):
    # Input a list of register indices, partition these registers into subsets
    # based on whether they share chi inputs.

    subsets = []  # list of subsets
    checked = []  # checked indices in index_list
    tbc = []      # index list to be checked
    for index in index_list:
        if index in checked:  # index already checked
            continue
        subset = [index] # add `index` to a new subset
        checked.append(index)
        tbc = related_indices(index)
        # Check if the indices in TBC exist in the index_list
        while len(tbc) > 0:
            c = tbc.pop(0) # currently checking chi input
            checked.append(c)
            if c in index_list:  # potential subset found
                subset.append(c)
                for c_rel in related_indices(c): # handle related indices of c
                    if c_rel in checked:  # c_rel already checked
                        continue
                    elif c_rel in tbc:  # c_rel already in checking list
                        continue
                    else:  # add c_rel to the checking list
                        tbc.append(c_rel)
        if len(subset) > 1:
            subsets.append(subset)
    return subsets

# Main
# Read result file generated by 'glitch_list_generation.py'
with open('glitch_list.json', 'r') as file:
    state_array = json.load(file)
    state_array = [[[[[tuple(index) for index in share]
                                    for share in state]
                                    for state in lane]
                                    for lane in sheet]
                                    for sheet in state_array]

    # Find all subsets for all glitch-extended probes
    subsets = []
    for x, sheet in enumerate(state_array):
        for y, lane in enumerate(sheet):
            for z, state in enumerate(lane):
                for s, index_list in enumerate(state):
                    # Different from `glitch_partition_subsets.py`
                    # Each index in the result of 'glitch_list_generation.py'
                    # corresponds to two registers:
                    # (x, y, z, s) -> d_{2s}[x, y, z], d_{2s+1}[x, y, z]
                    # Here, we convert them to register indices and add the 
                    # indix introduced by the transition.
                    transition_index_list = (
                        [(_x, _y, _z, 2 * _s) for _x, _y, _z, _s in index_list]
                        + [(_x, _y, _z, 2 * _s + 1)
                            for _x, _y, _z, _s in index_list]
                        + [(x, y, z, s)])  # transition
                    subsets += partition_subsets(transition_index_list)

    # Classify subsets for ease of reading and analysis
    classified_subsets = [[]]
    for subset in subsets:
        # How many rows are involved
        num_rows = len(set(W * y + z for x, y, z, s in subset))
        while num_rows > len(classified_subsets):
            classified_subsets.append([])
        # Only one row, save just their (x, s)
        if num_rows == 1:
            char = tuple(sorted([(x, s) for x, y, z, s in subset]))
            if char not in classified_subsets[0]:
                classified_subsets[0].append(char)
        # Multiple rows,
        # save their (j, x, s), where j is saved in relative terms
        else:
            j_min = min([W * y + z for x, y, z, s in subset])
            char = tuple(sorted([(W * y + z - j_min, x, s)
                                 for x, y, z, s in subset]))
            if char not in classified_subsets[num_rows - 1]:
                classified_subsets[num_rows - 1].append(char)

    # Show classified subsets
    for i, subsets in enumerate(classified_subsets):
        if i == 0:
            print(f'Number of 1-row subsets (x, share): {len(subsets)}')
        else:
            print(f'Number of {i + 1}-row subsets (j, x, share): ' +
                  f'{len(subsets)}')
        for subset in subsets:
            print(subset)

    # Show transition related subsets
    # number of elements in `subset` is odd
    print(f'Transition related subsets:')
    transition_classified_subsets = [[]]
    for i, subsets in enumerate(classified_subsets):
        for subset in subsets:
            if (len(subset) % 2) == 1:
                print(subset)
                while (i + 1) > len(transition_classified_subsets):
                    transition_classified_subsets.append([])
                transition_classified_subsets[i].append(subset)

    # Save subsets
    with open('glitch+trans_subsets.json', 'w') as file2:
        json.dump(transition_classified_subsets, file2)
