# glitch_partition_subsets, partition index lists into independent subsets.
# Copyright (C) 2024, Cankun Zhao, Leibo Liu. All rights reserved.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTERS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Please see LICENSE and README for license and further instructions.
#
# Contact: zhaock97@gmail.com

import json

W = 64


def related_indices(index):
    # Input the index of a register, output indices of related registers that
    # use common chi inputs with the input register.
    # NOTE: each index in the output corresponds to two registers
    # (x, y, z, s) -> d_{2s}[x, y, z], d_{2s+1}[x, y, z]

    x, y, z, s = index

    # chi_list: chi inputs used in calculating this register
    chi_list = [(x, y, z), ((x + 1) % 5, y, z), ((x + 2) % 5, y, z)]

    # chi inputs used in Changing Of The Guard (COTG)
    j = W * y + z
    if j > 0:
        jj = (j - 11) % (5 * W)
        yy = jj // W
        zz = jj % W
        if x == 0:
            chi_list.append((0, yy, zz))
        if x == 1:
            chi_list.append((1, yy, zz))

    # find indices of registers which use chi inputs in chi_list
    index_list = []
    for xx, yy, zz in chi_list:
        # each index corresponds to two registers
        # (x, y, z, s) -> d_{2s}[x, y, z], d_{2s+1}[x, y, z]
        index_list += [(xx, yy, zz, 0), (xx, yy, zz, 1),
                       ((xx - 1) % 5, yy, zz, 0), ((xx - 1) % 5, yy, zz, 1),
                       ((xx - 2) % 5, yy, zz, 0), ((xx - 2) % 5, yy, zz, 1)]
        # COTG
        jj = W * yy + zz
        j = (jj + 11) % (5 * W)
        if j > 0:
            y = j // W
            z = j % W
            if xx == 0:
                index_list += [(0, y, z, 0), (0, y, z, 1)]
            if xx == 1:
                index_list += [(1, y, z, 0), (1, y, z, 1)]

    # Remove duplicate indices
    index_list = list(set(index_list))
    # Remove index itself from index_list
    index_list.remove(index)
    return index_list


def partition_subsets(index_list):
    # Input a list of register indices, partition these registers into subsets
    # based on whether they share chi inputs.

    subsets = []  # list of subsets
    checked = []  # checked indices in index_list
    tbc = []      # index list to be checked
    for index in index_list:
        if index in checked:  # index already checked
            continue
        subset = [index] # add `index` to a new subset
        checked.append(index)
        tbc = related_indices(index)
        # Check if the indices in TBC exist in the index_list
        while len(tbc) > 0:
            c = tbc.pop(0) # currently checking chi input
            checked.append(c)
            if c in index_list: # potential subset found
                subset.append(c)
                for c_rel in related_indices(c): # handle related indices of c
                    if c_rel in checked:  # c_rel already checked
                        continue
                    elif c_rel in tbc:  # c_rel already in checking list
                        continue
                    else:  # add c_rel to the checking list
                        tbc.append(c_rel)
        if len(subset) > 1:
            subsets.append(subset)
    return subsets

# Main
# Read result file generated by 'glitch_list_generation.py'
with open('glitch_list.json', 'r') as file:
    state_array = json.load(file)
    state_array = [[[[[tuple(index) for index in share]
                                    for share in state]
                                    for state in lane]
                                    for lane in sheet]
                                    for sheet in state_array]

    # Find all subsets for all glitch-extended probes
    subsets = []
    for x, sheet in enumerate(state_array):
        for y, lane in enumerate(sheet):
            for z, state in enumerate(lane):
                for s, index_list in enumerate(state):
                    subsets += partition_subsets(index_list)

    # Classify subsets for ease of reading and analysis
    classified_subsets = [[]]
    for subset in subsets:
        # How many rows are involved
        num_rows = len(set(W * y + z for x, y, z, s in subset))
        while num_rows > len(classified_subsets):
            classified_subsets.append([])
        # Only one row, save just their (x, s)
        if num_rows == 1:
            char = tuple(sorted([(x, s) for x, y, z, s in subset]))
            if char not in classified_subsets[0]:
                classified_subsets[0].append(char)
        # Multiple rows,
        # save their (j, x, s), where j is saved in relative terms
        else:
            j_min = min([W * y + z for x, y, z, s in subset])
            char = tuple(sorted([(W * y + z - j_min, x, s)
                                 for x, y, z, s in subset]))
            if char not in classified_subsets[num_rows - 1]:
                classified_subsets[num_rows - 1].append(char)

    # Show classified subsets
    for i, subsets in enumerate(classified_subsets):
        if i == 0:
            print(f'Number of 1-row subsets (x, share): {len(subsets)}')
        else:
            print(f'Number of {i + 1}-row subsets (j, x, share): ' +
                  f'{len(subsets)}')
        for subset in subsets:
            print(subset)

    # Save subsets
    with open('glitch_subsets.json', 'w') as file2:
        json.dump(classified_subsets, file2)
