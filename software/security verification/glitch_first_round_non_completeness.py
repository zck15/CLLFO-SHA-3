# glitch_first_round_non_completeness, check the non-completeness of the first
# round.
# Copyright (C) 2024, Cankun Zhao, Leibo Liu. All rights reserved.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTERS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Please see LICENSE and README for license and further instructions.
#
# Contact: zhaock97@gmail.com

import json

# Read result file generated by 'glitch_list_generation.py'
with open('glitch_list.json', 'r') as file:
    state_array = json.load(file)
    state_array = [[[[[tuple(index) for index in share]
                                    for share in state]
                                    for state in lane]
                                    for lane in sheet]
                                    for sheet in state_array]
    # Search for non-completeness violations in the first round
    leak_list = [] # Used to save found violations
    # For each register (glitch-robust probe) and corresponding list
    for x, sheet in enumerate(state_array):
        for y, lane in enumerate(sheet):
            for z, state in enumerate(lane):
                for s, index_list in enumerate(state):
                    leak = []
                    # For each index in the list
                    for index in set(index_list):
                        # Generate the index of the other share
                        index_leak = (index[0], index[1],     # (x, y,
                                      index[2], 1 - index[3]) #  z, share)
                        # Check if the other share is in the list
                        # (violation of non-completeness)
                        if index_leak in index_list:
                            leak.append(index)
                    # If violation exists
                    if len(leak) > 0:
                        leak_list.append([(x, y, z, s), leak])

    print(f'The number of index lists violating non-completeness:' +
          f' {len(leak_list)}')
